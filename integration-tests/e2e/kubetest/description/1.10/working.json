[
  { "testcase": "[Conformance]", "is-substring": true, "focus": "Serial|Slow", "groups": ["slow"]},
  { "testcase": "[Conformance]", "is-substring": true, "skip": "Serial|Slow", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl apply apply set/view last-applied", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl apply should apply a new configuration to an existing RC", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl apply should reuse port when apply to an existing SVC", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl create quota should create a quota with scopes", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl create quota should create a quota without scopes", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl create quota should reject quota with invalid scopes", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl run CronJob should create a CronJob", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should handle in-cluster config", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should return command exit codes", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support exec", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support exec through an HTTP proxy", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support exec through kubectl proxy", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support inline execution and attach", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support port-forward", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects a client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects a client request should support a client that connects, sends NO DATA, and disconnects", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects NO client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 should support forwarding over websockets", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects a client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects a client request should support a client that connects, sends NO DATA, and disconnects", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects NO client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"] },
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost should support forwarding over websockets", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Garbage collector should support cascading deletion of custom resources", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes", "groups": ["fast"] },
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return pod details", "groups": ["fast"] },
  { "testcase": "[sig-apps] CronJob should delete successful finished jobs with limit of one successful job", "groups": ["fast"] },
  { "testcase": "[sig-apps] CronJob should not emit unexpected warnings", "groups": ["fast"] },
  { "testcase": "[sig-apps] CronJob should remove from active list jobs that have been deleted", "groups": ["fast"] },
  { "testcase": "[sig-apps] CronJob should replace jobs when ReplaceConcurrent", "groups": ["fast"] },
  { "testcase": "[sig-apps] CronJob should schedule multiple jobs concurrently", "groups": ["fast"] },
  { "testcase": "[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods", "groups": ["fast"] },
  { "testcase": "[sig-apps] Deployment deployment should support rollback", "groups": ["fast"] },
  { "testcase": "[sig-apps] Deployment iterative rollouts should eventually progress", "groups": ["fast"] },
  { "testcase": "[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: no PDB => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController should create a PodDisruptionBudget", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController should update PodDisruptionBudget status", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should adopt matching orphans and release non-matching pods", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should delete a job", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should exceed active deadline", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should exceed backoffLimit", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted", "groups": ["fast"] },
  { "testcase": "[sig-apps] Job should run a job to completion when tasks succeed", "groups": ["fast"] },
  { "testcase": "[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota", "groups": ["fast"] },
  { "testcase": "[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota", "groups": ["fast"] },
  { "testcase": "[sig-auth] Certificates API should support building a client with a CSR", "groups": ["fast"] },
  { "testcase": "[sig-auth] PodSecurityPolicy should forbid pod creation when no PSP is available", "groups": ["fast"] },
  { "testcase": "[sig-auth] ServiceAccounts should ensure a single API token exists", "groups": ["fast"] },
  { "testcase": "[sig-instrumentation] Cadvisor should be healthy on every node.", "groups": ["fast"] },
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from API server.", "groups": ["fast"] },
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.", "groups": ["fast"] },
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.", "groups": ["fast"] },
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.", "groups": ["fast"] },
  { "testcase": "[sig-network] DNS should provide DNS for pods for Hostname and Subdomain", "groups": ["fast"] },
  { "testcase": "[sig-network] DNS should support configurable pod resolv.conf", "groups": ["fast"] },
  { "testcase": "[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should be able to change the type from ClusterIP to ExternalName", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should be able to change the type from ExternalName to ClusterIP", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should be able to change the type from ExternalName to NodePort", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should be able to change the type from NodePort to ExternalName", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should be able to update NodePorts with two same port numbers but different protocols", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should check NodePort out-of-range", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should create endpoints for unready pods", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should preserve source pod IP for traffic thru service cluster IP", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should prevent NodePort collisions", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should release NodePorts on delete", "groups": ["fast"] },
  { "testcase": "[sig-network] Services should use same NodePort with same port but different protocols", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a configMap.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a pod.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a replica set.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a replication controller.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a secret.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and capture the life of a service.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should verify ResourceQuota with best effort scope.", "groups": ["fast"] },
  { "testcase": "[sig-scheduling] ResourceQuota should verify ResourceQuota with terminating scopes.", "groups": ["fast"] },
  { "testcase": "[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap", "groups": ["fast"] },
  { "testcase": "[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected", "groups": ["fast"] },
  { "testcase": "[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret", "groups": ["fast"] },
  { "testcase": "[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately", "groups": ["fast"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access", "groups": ["fast"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access", "groups": ["fast"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access", "groups": ["fast"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access ", "groups": ["fast"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access", "groups": ["fast"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access", "groups": ["fast"] },
  { "testcase": "[sig-storage] Volumes ConfigMap should be mountable", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction", "groups": ["fast", "debug1"] },
  { "testcase": "[sig-apps] DisruptionController evictions: no PDB => should allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction", "groups": ["fast"] },
  { "testcase": "[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately", "exclude": [ "alicloud" ], "groups": ["fast"] },
  { "testcase": "[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable", "exclude": [ "alicloud" ], "groups": ["fast"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods", "exclude": [ "alicloud" ], "groups": ["fast"] },
  { "testcase": "[k8s.io] [sig-node] Kubelet [Serial] [Slow] [k8s.io] [sig-node] regular resource usage tracking resource tracking for 100 pods per node", "groups": ["slow"] },
  { "testcase": "[k8s.io] EquivalenceCache [Serial] validates GeneralPredicates is properly invalidated when a pod is scheduled [Slow]", "groups": ["slow"] },
  { "testcase": "[k8s.io] EquivalenceCache [Serial] validates pod affinity works properly when new replica pod is scheduled", "groups": ["slow"] },
  { "testcase": "[k8s.io] EquivalenceCache [Serial] validates pod anti-affinity works properly when new replica pod is scheduled", "groups": ["slow"] },
  { "testcase": "[sig-api-machinery] Namespaces [Serial] should delete fast enough (90 percent of 100 namespaces in 150 seconds)", "groups": ["slow"] },
  { "testcase": "[sig-apps] CronJob should not schedule jobs when suspended [Slow]", "groups": ["slow"] },
  { "testcase": "[sig-apps] CronJob should not schedule new jobs when ForbidConcurrent [Slow]", "groups": ["slow"] },
  { "testcase": "[sig-apps] Daemon set [Serial] should not update pod when spec was updated and update strategy is OnDelete", "groups": ["slow"] },
  { "testcase": "[sig-apps] Daemon set [Serial] should run and stop complex daemon with node affinity", "groups": ["slow"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] Deployment Should scale from 1 pod to 3 pods and from 3 to 5", "groups": ["slow"], "exclude": ["gcp"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] ReplicaSet Should scale from 1 pod to 3 pods and from 3 to 5", "groups": ["slow"], "exclude": ["gcp"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] ReplicationController Should scale from 1 pod to 3 pods and from 3 to 5 and verify decision stability", "groups": ["slow"], "exclude": ["gcp"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl taint [Serial] should remove all the taints with the same key off a node", "groups": ["slow"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl taint [Serial] should update the taint on a node", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates MaxPods limit number of pods that are allowed to run [Slow]", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that NodeAffinity is respected if not matching", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that required NodeAffinity setting is respected if matching", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that taints-tolerations is respected if matching", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that taints-tolerations is respected if not matching", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP", "groups": ["slow"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol", "groups": ["slow"] },
  { "testcase": "[sig-storage] Dynamic Provisioning DynamicProvisioner should provision storage with different parameters [Slow]", "groups": ["slow"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 4 PVs and 2 PVCs: test write access [Slow]", "groups": ["slow"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  Local volume that cannot be mounted [Slow] should fail due to non-existent path", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete", "groups": ["slow"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] ReplicationController light Should scale from 2 pods to 1 pod", "groups": ["slow"] },
  { "testcase": "[k8s.io] Pods should have their auto-restart back-off timer reset on image update [Slow]", "groups": ["slow"] },
  { "testcase": "[k8s.io] Pods should cap back-off at MaxContainerBackOff [Slow]", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity", "groups": ["slow"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] ReplicationController light Should scale from 1 pod to 2 pods", "groups": ["slow"] },
  { "testcase": "[sig-network] DNS should provide DNS for ExternalName services", "groups": ["slow"] },
  { "testcase": "[k8s.io] Probing container should be restarted with a /healthz http liveness probe  [Conformance]", "groups": ["slow"] },
  { "testcase": "[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe  [Conformance]", "groups": ["slow"] },
  { "testcase": "[k8s.io] Probing container should have monotonically increasing restart count  [Slow] [Conformance]", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Conformance]", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Conformance]", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]", "groups": ["slow"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Guestbook application should create and stop a working application  [Conformance]", "groups": ["slow"] }
]