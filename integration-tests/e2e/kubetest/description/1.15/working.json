[
  { "testcase": "[Conformance]", "is-substring": true, "focus": "Serial|Slow", "groups": ["slow", "slow2"]},
  { "testcase": "[Conformance]", "is-substring": true, "skip": "Serial|Slow", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Sysctls [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node", "groups": ["fast"]},
  { "testcase": "[k8s.io] Sysctls [NodeFeature:Sysctls] should reject invalid sysctls", "groups": ["fast"]},
  { "testcase": "[k8s.io] Sysctls [NodeFeature:Sysctls] should support sysctls", "groups": ["fast"]},
  { "testcase": "[k8s.io] Sysctls [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl apply apply set/view last-applied", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl apply should apply a new configuration to an existing RC", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl apply should reuse port when apply to an existing SVC", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl cluster-info dump should check if cluster-info dump succeeds", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl copy should copy a file from a running Pod", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl create quota should create a quota with scopes", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl create quota should create a quota without scopes", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl create quota should reject quota with invalid scopes", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl run CronJob should create a CronJob", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should return command exit codes", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support exec", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support exec through an HTTP proxy", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support exec through kubectl proxy", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support port-forward", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects a client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects a client request should support a client that connects, sends NO DATA, and disconnects", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects NO client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 should support forwarding over websockets", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects a client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects a client request should support a client that connects, sends NO DATA, and disconnects", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects NO client request should support a client that connects, sends DATA, and disconnects", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost should support forwarding over websockets", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]", "groups": ["fast"]},
  { "testcase": "[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Downward API volume should provide podname as non-root with fsgroup [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)", "groups": ["fast"]},
  { "testcase": "[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root", "groups": ["fast"]},
  { "testcase": "[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root", "groups": ["fast"]},
  { "testcase": "[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup", "groups": ["fast"]},
  { "testcase": "[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup", "groups": ["fast"]},
  { "testcase": "[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup", "groups": ["fast"]},
  { "testcase": "[sig-storage] HostPath should support r/w [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[sig-storage] HostPath should support subPath [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set fsGroup for one pod [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set same fsGroup for two pods simultaneously [Slow]", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2", "groups": ["fast"]},
  { "testcase": "[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [NodeFeature:FSGroup]", "groups": ["fast"]},
  { "testcase": "[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from docker hub [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from gcr.io [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull non-existing image from gcr.io [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourceDefinition Watch CustomResourceDefinition Watch watch on custom resource definition objects", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Garbage collector should support cascading deletion of custom resources", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Garbage collector should support orphan deletion of custom resources", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Servers with support for Table transformation should return pod details", "groups": ["fast"]},
  { "testcase": "[sig-apps] CronJob should remove from active list jobs that have been deleted", "groups": ["fast"]},
  { "testcase": "[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods", "groups": ["fast"]},
  { "testcase": "[sig-apps] Deployment deployment should support rollback", "groups": ["fast"]},
  { "testcase": "[sig-apps] Deployment iterative rollouts should eventually progress", "groups": ["fast"]},
  { "testcase": "[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: no PDB => should allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController should create a PodDisruptionBudget", "groups": ["fast"]},
  { "testcase": "[sig-apps] DisruptionController should update PodDisruptionBudget status", "groups": ["fast"]},
  { "testcase": "[sig-apps] Job should adopt matching orphans and release non-matching pods", "groups": ["fast"]},
  { "testcase": "[sig-apps] Job should exceed active deadline", "groups": ["fast"]},
  { "testcase": "[sig-apps] Job should exceed backoffLimit", "groups": ["fast"]},
  { "testcase": "[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted", "groups": ["fast"]},
  { "testcase": "[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted", "groups": ["fast"]},
  { "testcase": "[sig-apps] Job should run a job to completion when tasks succeed", "groups": ["fast"]},
  { "testcase": "[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota", "groups": ["fast"]},
  { "testcase": "[sig-auth] Certificates API should support building a client with a CSR", "groups": ["fast"]},
  { "testcase": "[sig-auth] PodSecurityPolicy should forbid pod creation when no PSP is available", "groups": ["fast"]},
  { "testcase": "[sig-auth] ServiceAccounts should ensure a single API token exists", "groups": ["fast"]},
  { "testcase": "[sig-instrumentation] Cadvisor should be healthy on every node.", "groups": ["fast"]},
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from API server.", "groups": ["fast"]},
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.", "groups": ["fast"]},
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.", "groups": ["fast"]},
  { "testcase": "[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.", "groups": ["fast"]},
  { "testcase": "[sig-network] DNS should support configurable pod resolv.conf", "groups": ["fast"]},
  { "testcase": "[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to change the type from ClusterIP to ExternalName", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to change the type from ExternalName to ClusterIP", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to change the type from ExternalName to NodePort", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to change the type from NodePort to ExternalName", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to switch session affinity for NodePort service", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to switch session affinity for service with type clusterIP", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to update NodePorts with two same port numbers but different protocols", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should check NodePort out-of-range", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should create endpoints for unready pods", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should have session affinity work for NodePort service", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should have session affinity work for service with type clusterIP", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should prevent NodePort collisions", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should release NodePorts on delete", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should use same NodePort with same port but different protocols", "groups": ["fast"]},
  { "testcase": "[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes.", "groups": ["fast"]},
  { "testcase": "[sig-storage] Dynamic Provisioning DynamicProvisioner allowedTopologies should create persistent volume in the zone specified in allowedTopologies of storageclass", "groups": ["fast"]},
  { "testcase": "[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap", "groups": ["fast"]},
  { "testcase": "[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected", "groups": ["fast"]},
  { "testcase": "[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret", "groups": ["fast"]},
  { "testcase": "[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access ", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector", "groups": ["fast"]},
  { "testcase": "[sig-storage] Volumes ConfigMap should be mountable", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with defaults", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with defaults", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"]},
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should be mountable", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]", "groups": ["fast", "debug1"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should be mountable", "groups": ["fast"]},
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods", "groups": ["fast"], "exclude": ["alicloud"] },
  { "testcase": "[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately", "groups": ["fast"], "exclude": ["alicloud"] },
  { "testcase": "[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable", "groups": ["fast"], "exclude": ["alicloud"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should support inline execution and attach", "groups": ["fast"], "exclude": ["aws"] },
  { "testcase": "[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]", "groups": ["fast"], "only": ["gcp", "openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support existing directory", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support existing single file", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] volumes should be mountable", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources", "groups": ["fast"], "only": ["openstack"] },
  { "testcase": "[k8s.io] EquivalenceCache [Serial] validates GeneralPredicates is properly invalidated when a pod is scheduled [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] EquivalenceCache [Serial] validates pod affinity works properly when new replica pod is scheduled", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] EquivalenceCache [Serial] validates pod anti-affinity works properly when new replica pod is scheduled", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-api-machinery] Namespaces [Serial] should delete fast enough (90 percent of 100 namespaces in 150 seconds)", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] CronJob should not schedule jobs when suspended [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] CronJob should not schedule new jobs when ForbidConcurrent [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] Daemon set [Serial] should not update pod when spec was updated and update strategy is OnDelete", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] Daemon set [Serial] should run and stop complex daemon with node affinity", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] Deployment Should scale from 1 pod to 3 pods and from 3 to 5", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] Deployment Should scale from 5 pods to 3 pods and from 3 to 1", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] ReplicaSet Should scale from 1 pod to 3 pods and from 3 to 5", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] ReplicaSet Should scale from 5 pods to 3 pods and from 3 to 1", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] [Serial] [Slow] ReplicationController Should scale from 1 pod to 3 pods and from 3 to 5 and verify decision stability", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl taint [Serial] should remove all the taints with the same key off a node", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl taint [Serial] should update the taint on a node", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] NoExecuteTaintManager Multiple Pods [Serial] evicts pods with minTolerationSeconds", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] NoExecuteTaintManager Multiple Pods [Serial] only evicts pods without tolerations from tainted nodes", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] NoExecuteTaintManager Single Pod [Serial] doesn't evict pod with tolerations from tainted nodes", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] NoExecuteTaintManager Single Pod [Serial] eventually evict pod with finite tolerations from tainted nodes", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] NoExecuteTaintManager Single Pod [Serial] evicts pods from tainted nodes", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] NoExecuteTaintManager Single Pod [Serial] removing taint cancels eviction", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] PodPriorityResolution [Serial] validates critical system priorities are created and resolved", "groups": ["slow", "slow2", "debug2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates MaxPods limit number of pods that are allowed to run [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that NodeAffinity is respected if not matching", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that required NodeAffinity setting is respected if matching", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that taints-tolerations is respected if matching", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that taints-tolerations is respected if not matching", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that there exists conflict between pods with same hostPort and protocol but one using 0.0.0.0 hostIP", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPredicates [Serial] validates that there is no conflict between pods with same hostPort but different hostIP and protocol", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPreemption [Serial] validates basic preemption works", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPreemption [Serial] validates lower priority pod preemption by critical pod", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] SchedulerPreemption [Serial] validates pod anti-affinity works in preemption", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] ConfigMap Should fail non-optional pod creation due to configMap object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] ConfigMap Should fail non-optional pod creation due to the key in the configMap object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Dynamic Provisioning DynamicProvisioner [Slow] should provision storage with different parameters", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Dynamic Provisioning DynamicProvisioner delayed binding [Slow] should create persistent volumes in the same zone as node after a pod mounting the claims is started", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Dynamic Provisioning DynamicProvisioner delayed binding with allowedTopologies [Slow] should create persistent volumes in the same zone as specified in allowedTopologies after a pod mounting the claims is started", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Dynamic Provisioning DynamicProvisioner External should let an external dynamic provisioner create and delete persistent volumes [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] EmptyDir wrapper volumes should not cause race condition when used for git_repo [Serial] [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 4 PVs and 2 PVCs: test write access [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  Local volume that cannot be mounted [Slow] should fail due to non-existent path", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  Local volume that cannot be mounted [Slow] should fail due to wrong node", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  StatefulSet with pod affinity [Slow] should use volumes on one node when pod has affinity", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  StatefulSet with pod affinity [Slow] should use volumes on one node when pod management is parallel and pod has affinity", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Projected configMap Should fail non-optional pod creation due to configMap object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Projected configMap Should fail non-optional pod creation due to the key in the configMap object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Projected secret Should fail non-optional pod creation due to secret object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Projected secret Should fail non-optional pod creation due to the key in the secret object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Secrets Should fail non-optional pod creation due to secret object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] Secrets Should fail non-optional pod creation due to the key in the secret object does not exist [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] ReplicationController light Should scale from 2 pods to 1 pod", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Pods should have their auto-restart back-off timer reset on image update [Slow][NodeConformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-api-machinery] Servers with support for API chunking should support continue listing from the last key if the original version has been compacted away, though the list is inconsistent", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Pods should cap back-off at MaxContainerBackOff [Slow][NodeConformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should fail if subpath file is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support restarting containers using file as subpath [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should fail if subpath file is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support restarting containers using file as subpath [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath file is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using file as subpath [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath file is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using file as subpath [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath file is outside the volume [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using file as subpath [Slow][LinuxOnly]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (block volmode)] volumeMode should fail in binding dynamic provisioned PV to PVC", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] ReplicationController light Should scale from 1 pod to 2 pods", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should be mountable", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-network] DNS should provide DNS for ExternalName services [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] volumes should be mountable", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] CronJob should schedule multiple jobs concurrently", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] CronJob should replace jobs when ReplaceConcurrent", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] CronJob should not emit unexpected warnings", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] CronJob should delete successful finished jobs with limit of one successful job", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-network] Services should preserve source pod IP for traffic thru service cluster IP", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Guestbook application should create and stop a working application  [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]", "groups": ["slow"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails", "groups": ["slow", "slow2"], "exclude": ["alicloud"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs", "groups": ["slow", "slow2"], "exclude": ["alicloud"] },
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity", "groups": ["slow", "slow2"], "exclude": ["alicloud"] },
  { "testcase": "[sig-scheduling] SchedulerPriorities [Serial] Pod should avoid nodes that have avoidPod annotation", "groups": ["slow", "slow2"], "exclude": ["alicloud"] },
  { "testcase": "[sig-scheduling] SchedulerPriorities [Serial] Pod should be preferably scheduled to nodes pod can tolerate", "groups": ["slow", "slow2"], "exclude": ["alicloud"] },
  { "testcase": "[sig-scheduling] SchedulerPriorities [Serial] Pod should be scheduled to node that don't match the PodAntiAffinity terms", "groups": ["slow", "slow2"], "exclude": ["alicloud"] },
  { "testcase": "[sig-network] Services should have session affinity work for LoadBalancer service with ESIPP on [Slow] [DisabledForLargeClusters]", "groups": ["slow", "slow2"], "only": ["gcp", "openstack"] },
  { "testcase": "[sig-network] Services should have session affinity work for LoadBalancer service with ESIPP off [Slow] [DisabledForLargeClusters]", "groups": ["slow", "slow2"], "only": ["gcp", "openstack"] },
  { "testcase": "[sig-network] Services should be able to switch session affinity for LoadBalancer service with ESIPP off [Slow] [DisabledForLargeClusters]", "groups": ["slow", "slow2"], "only": ["gcp", "openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath file is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support creating multiple subpath from same volumes [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] subPath should support restarting containers using file as subpath [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Inline-volume (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should fail if non-existent subpath is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should fail if subpath directory is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should fail if subpath file is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should fail if subpath with backstepping is outside the volume [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support restarting containers using directory as subpath [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] subPath should support restarting containers using file as subpath [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (default fs)] volumeIO should write files of various sizes, verify size, validate content [Slow]", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-storage] In-tree Volumes [Driver: ceph][Feature:Volumes] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should fail to create pod by failing to mount volume", "groups": ["slow", "slow2"], "only": ["openstack"] },
  { "testcase": "[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-network] DNS should provide DNS for pods for Subdomain", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI updates the published spec when one versin gets renamed", "groups": ["fast"]},
  { "testcase": "[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should contain last line of the log", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI removes definition from spec when one versin gets changed to not be served", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for multiple CRDs of same group and version but different kinds", "groups": ["fast"]},
  { "testcase": "[k8s.io] Probing container should be restarted with a local redirect http liveness probe", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for multiple CRDs of different groups", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID", "groups": ["fast"]},
  { "testcase": "[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass", "groups": ["fast"]},
  { "testcase": "[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass", "groups": ["fast"]},
  { "testcase": "[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD with validation schema", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl client-side validation should create/apply a valid CR for CRD with validation schema", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD without validation schema", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourceConversionWebhook Should be able to convert a non homogeneous list of CRs", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourceConversionWebhook Should be able to convert from CR v1 to CR v2", "groups": ["fast"]},
  { "testcase": "[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from gcr.io [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[sig-network] DNS should support configurable pod DNS nameservers", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from docker hub [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage][NodeFeature:VolumeSubpathEnvExpansion]", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]", "groups": ["fast"]},
  { "testcase": "[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]", "groups": ["fast"]},
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Kubectl get componentstatuses should get componentstatuses", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] Discovery Custom resource should have storage version hash", "groups": ["fast"]},
  { "testcase": "[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] ResourceQuota Should be able to update and delete ResourceQuota.", "groups": ["fast"]},
  { "testcase": "[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace", "groups": ["fast"]},  
  { "testcase": "[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC", "groups": ["fast"]},
  { "testcase": "[sig-network] Services should be able to switch session affinity for LoadBalancer service with ESIPP on [Slow] [DisabledForLargeClusters]", "groups": ["slow", "slow2"], "only": ["azure","gcp"] },
  { "testcase": "[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Variable Expansion should not change the subpath mount on a container restart if the environment variable changes [sig-storage][NodeFeature:VolumeSubpathEnvExpansion][Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Variable Expansion should verify that a failing subpath expansion can be modified during the lifecycle of a container [sig-storage][NodeFeature:VolumeSubpathEnvExpansion][Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Variable Expansion should fail substituting values in a volume subpath with absolute path [sig-storage][NodeFeature:VolumeSubpathEnvExpansion][Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Variable Expansion should fail substituting values in a volume subpath with backticks [sig-storage][NodeFeature:VolumeSubpathEnvExpansion][Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  Stress with local volumes [Serial] should be able to process many pods and reuse local volumes", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI volume limit information using mock driver should report attach limit when limit is bigger than 0 [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-network] Network should resolve connrection reset issue #74839 [Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-network] Services should remove load balancer cleanup finalizer when service is deleted [Slow]", "exclude": ["alicloud"], "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] [sig-node] PreStop graceful pod terminated should wait until preStop hook completes the process", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PersistentVolumes-local  Pods sharing a single local PV [Serial] all pods should be running", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for multiple CRDs of same group but different versions", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod", "exclude": ["alicloud"], "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Variable Expansion should succeed in writing subpaths in container [sig-storage][NodeFeature:VolumeSubpathEnvExpansion][Slow]", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-cli] Kubectl client [k8s.io] Simple pod should handle in-cluster config", "groups": ["slow", "slow2"] },
  { "testcase": "[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment", "groups": ["slow", "slow2"] },
  { "testcase": "[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]", "groups": ["slow", "slow2"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD preserving unknown fields at the schema root", "groups": ["fast"]},
  { "testcase": "[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD preserving unknown fields in an embedded object", "groups": ["fast"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  Pods sharing a single local PV [Serial] all pods should be running", "groups": ["slow", "slow2"]},
  { "testcase": "[sig-storage] PersistentVolumes-local  Stress with local volumes [Serial] should be able to process many pods and reuse local volumes", "groups": ["slow", "slow2"]},
  { "testcase": "[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]", "groups": ["slow", "slow2"]}
]